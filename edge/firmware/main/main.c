#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdint.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "esp_heap_caps.h"

#include "model_data.h"      // Generated by tflite_to_cc.py
#include "cp_params.h"       // Generated by compute_cp_thresholds.py

#include "tensorflow/lite/micro/all_ops_resolver.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/micro/micro_log.h"

static const char *TAG = "ECG-CP";

// Adjust arena size if allocation fails; consider PSRAM-enabled boards
// For ESP32S3 with PSRAM, you may place this in external RAM if needed.
static const int kTensorArenaSize = 400 * 1024; // 400 KB
static uint8_t tensor_arena[kTensorArenaSize];

// Inference input dimensions
#define SAMPLES 1000
#define LEADS   12

static inline int8_t quantize_input_sample(float x_norm) {
    // Quantize normalized float to int8 using TFLite input scale/zp
    float q = roundf(x_norm / CP_IN_SCALE) + (float)CP_IN_ZP;
    if (q < -128.f) q = -128.f;
    if (q > 127.f)  q = 127.f;
    return (int8_t)q;
}

static inline float dequantize_output(int8_t q) {
    return CP_OUT_SCALE * ((int)q - CP_OUT_ZP);
}

static void preprocess_and_quantize(const float *x_raw, int8_t *x_q) {
    // x_raw: [SAMPLES * LEADS], interleaved [t0 L0..L11, t1 L0..L11, ...]
    for (int t = 0; t < SAMPLES; ++t) {
        for (int c = 0; c < LEADS; ++c) {
            float x = x_raw[t * LEADS + c];
            float x_norm = (x - CP_LEAD_MEAN[c]) / CP_LEAD_STD[c];
            x_q[t * LEADS + c] = quantize_input_sample(x_norm);
        }
    }
}

extern "C" void app_main(void) {
    ESP_LOGI(TAG, "Starting ECG CP demo (ESP32S3)");

    // Report heap before
    size_t heap_before = heap_caps_get_free_size(MALLOC_CAP_8BIT);
    ESP_LOGI(TAG, "Free heap before: %d bytes", (int)heap_before);

    // Load TFLite model
    const tflite::Model* model = tflite::GetModel(g_model_data);
    if (model->version() != TFLITE_SCHEMA_VERSION) {
        ESP_LOGE(TAG, "Model schema mismatch");
        return;
    }

    // Resolver and interpreter
    static tflite::AllOpsResolver resolver;
    tflite::MicroInterpreter interpreter(model, resolver, tensor_arena, kTensorArenaSize);
    TfLiteStatus alloc_status = interpreter.AllocateTensors();
    if (alloc_status != kTfLiteOk) {
        ESP_LOGE(TAG, "AllocateTensors failed");
        return;
    }

    // I/O tensors
    TfLiteTensor* input = interpreter.input(0);
    TfLiteTensor* output = interpreter.output(0);

    if (input->type != kTfLiteInt8 || output->type != kTfLiteInt8) {
        ESP_LOGW(TAG, "Expected INT8 I/O; got in=%d out=%d", input->type, output->type);
    }

    // Dummy input: sinusoid demo (replace with real ECG samples)
    static float x_demo[SAMPLES * LEADS];
    memset(x_demo, 0, sizeof(x_demo));
    for (int t = 0; t < SAMPLES; ++t) {
        float s = sinf(2.0f * 3.1415926f * (float)t / 50.0f);
        for (int c = 0; c < LEADS; ++c) {
            x_demo[t * LEADS + c] = s * 100.0f; // arbitrary amplitude (uV)
        }
    }

    // Quantize input
    preprocess_and_quantize(x_demo, input->data.int8);

    // Measure inference latency
    const int runs = 50;
    int64_t t0 = esp_timer_get_time();
    for (int i = 0; i < runs; ++i) {
        if (interpreter.Invoke() != kTfLiteOk) {
            ESP_LOGE(TAG, "Invoke failed at iter %d", i);
            break;
        }
    }
    int64_t t1 = esp_timer_get_time();
    float avg_us = (float)(t1 - t0) / (float)runs;

    // Read output (p(MI))
    int8_t q = output->data.int8[0];
    float p_mi = dequantize_output(q);

    // Mondrian CP decision using precomputed thresholds
    float s_norm = p_mi;         // hypothesis Normal
    float s_mi   = 1.0f - p_mi;  // hypothesis MI
    bool in_norm = (s_norm <= CP_TAU_NORM);
    bool in_mi   = (s_mi   <= CP_TAU_MI);

    // Report heap after
    size_t heap_after = heap_caps_get_free_size(MALLOC_CAP_8BIT);

    ESP_LOGI(TAG, "pMI=%.4f | s_norm=%.4f <= tau_norm=%.4f ? %s | s_mi=%.4f <= tau_mi=%.4f ? %s",
             p_mi, s_norm, CP_TAU_NORM, in_norm?"yes":"no",
             s_mi, CP_TAU_MI, in_mi?"yes":"no");
    ESP_LOGI(TAG, "Prediction set: {%s%s%s}",
             in_norm?"Normal":"",
             (in_norm && in_mi)?", ":"",
             in_mi?"MI":"");
    ESP_LOGI(TAG, "Average inference latency: %.2f us (%d runs)", avg_us, runs);
    ESP_LOGI(TAG, "Free heap after: %d bytes (delta %d)", (int)heap_after, (int)(heap_after - heap_before));

    // TODO: Integrate actual ECG stream (ADC/serial/BLE) to fill x_demo and run sliding-window inference.
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
